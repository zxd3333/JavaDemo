# 了解线程
在学习线程之前要先知道什么是进程，因为线程是依赖于进程的。  
进程就是正在运行的程序，它是系统资源分配和调度的独立单位，每个进程都有它自己的内存空间和系统资源    
线程是进程中的单个顺序控制流，是程序执行流的最小执行单位  

上面的概念性东西说了也看不太明白，简单一点说就是：一个程序就是一个进程，而一个程序中的多个任务则被称为线程  
举个例子，我们打开了一个浏览器，那这个浏览器就是一个进程，同时我们又打开音乐软件，它又是一个进程  
而在音乐软件里面搜索歌曲就是一个线程，查看歌词又是一个线程。

Java程序启动的时候，实际上是启动了一个JVM进程。  
JVM启动主线程来执行main()方法，在main()方法中，我们又可以启动其他线程
  
## 并发和并行
并行是指在同一时刻，有多条指令在多个处理器上同时运行
并发指的是在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行  
       宏观上具有多个进程同时执行的效果  
       微观上并不是同时执行的，只是把时间分成若干端，使多个进程快速交替的执行

## 创建线程的两个方法：
* 1.继承Thread类，重写run()方法，创建线程对象
* 2.实现Runnable接口并重写run()方法，创建线程对象

# 线程的状态：
* 1.新建，新建一个线程对象。
       Thread t = new Thread();
* 2.就绪，线程创建之后，调用start()方法后就进入就绪状态。  
        这个状态具有执行资格，但没有执行权，等待获取CPU的使用权。  
        t.start();
* 3.运行，进入就绪状态的线程抢到了CPU的使用权，执行run()方法中的代码
* 4.阻塞，如果一个线程在运行状态下出于某些原因放弃了CPU的使用权，线程就会进入阻塞状态  
        进入阻塞状态的线程恢复之后会重新进入就绪状态。  
        同步阻塞：运行线程获取对象的同步锁时，该同步锁被别的线程占用  
        主动阻塞：调用Thread的某些方法，例如sleep()、join()等  
        等待阻塞：即执行了wait()方法，该线程会进入线程池中等待
* 5.死亡，当线程的run()方法执行完毕或者线程出现了异常，线程就会进入死亡状态。

## synchronized关键字
synchronized关键字的出现是为了解决共享资源竞争的问题  
共享资源一般以对象的形式存在，要控制共享资源的访问，首先要把它包装成一个对象，然后把所有要访问的这个共享资源的方法标记为synchronized  
如果某个线程调用的方法被synchronized标记，那么在这个线程从该方法返回之前，调用类中任何标记为synchronized方法的线程都会被阻塞  
所有对象都自动含有单一的锁（也称为监视器）。当在对象上调用其任意标记为synchronized方法的时候，对象被加锁，这时候该对象上的其他synchronized方法只有等到前一个方法调用完毕并释放了锁之后才能被调用。